#!/usr/bin/env python
###############################################################################
#
# esri2tapnetnode.py - Convert ESRI data to TAP _net.txt and _node.txt files
#
# File:    esri2tapnetnode.py
# Author:  Alex Stivala
# Created: December 2010
#
# $Id: esri2tapnetnode.py 735 2011-09-21 07:19:31Z astivala $
#
###############################################################################

"""
Convert node and road information in ESRI format to net and node text
files in the format from

 http://www.bgu.ac.il/~bargera/tntp/

for use in traffic assignment programs (TAP).

See usage in docstring for main()

Requires that spatialite (v2.4) is installed in order to create access
spatialiate db from ESRI shapefiles and extract data from it.


"""


import sys,os,re,subprocess
from time import strftime, localtime

#-----------------------------------------------------------------------------
#
# Class definitions 
#
#-----------------------------------------------------------------------------

class Link:
    """
    Link is the class representing each link from the net file
    NB node numbers are numbered from 1

    BPR function: travel_time(Q) = T_0 * (1 + alpha*(Q/Q_max)^beta)
    """
    def __init__(self):
        init_node      = None  # from node number
        term_node      = None  # to node number
        capacity       = None  # Q_max in BPR function
        length         = None
        free_flow_time = None  # T_0 in BPR function
        B              = None  # alpha in BPR function
        power          = None  # beta in BPR function
        speed_limit    = None
        toll           = None
        link_type      = None

        # fields set by traffic assignment (not parsed)
        volume         = None  # volume on this link
        cost           = None  # cost on this link

#-----------------------------------------------------------------------------
#
# Function definitions
#
#-----------------------------------------------------------------------------

def  linkcmp(link1, link2):
    """
    comparison function for Link objects used to sort list of Link objects
    by 'from' node ascending and within that by 'to' node ascending
    """
    if link1.init_node <  link2.init_node:
        return -1
    elif link1.init_node > link2.init_node:
        return 1
    else:
        if link1.term_node < link2.term_node:
            return -1
        elif link1.term_node > link2.term_node:
            return 1
        else:
            return 0

def parse_bpr_param_matrix(matrix_filename):
    """
    Parse the BPR parameters ( alpha, beta) for each road type
    (actually CAPINDEX in SQL for some reson) from the MATLAB ASCII matrix
    file generated by the fitbprparams.m script from SpeedflowVoyager CSV data.

    Parameters:
       matrix_filename - filename of the MATLAB save bprparams -ascii file 
    
    Return value:
       list of tuples [(alpha, beta, freeflowspeed)] the BPR parameters for each
       capindex (2,..,19) NB list elements 0 and 1 are dummy, so can
       use capindex startnig at 2 directly
    """
    bpr_param_list = [(0,0,0)] # element 0 unused, line 1 in data also dummy
    bpr_param_list = bpr_param_list + \
    [ tuple([float(x) for x in line.split()]) for line in 
      open(matrix_filename).readlines() ] 
    return bpr_param_list

def esri2tapnetnode(road_shapefile, node_shapefile, zone_shapefile,
                    matrix_filename,
                    netfile_fh, nodefile_fh, mapfile_fh):
    """
    Convert ESRI shapfiles to TAP input file format.

    Parameters:
      road_shapefile -  ESRI shapefile containing roads (links) data
      node_shapefile  -  ESRI shapefile containing nodes data
      zone_shapefile - ESRI shapefile containign zones data
      matrix_filename - filename of the MATLAB save bprparams -ascii file 
      netfile_fh - open (write) filehandle to write net txt file to
      nodefile_fh - open (write) filehandle to write node txt file to
      mapfile_fh - open (write) fh to write old->new node number mape to

    Return value:
       None.
       
    Note input shapefiles have the names

    X.shp
    X.dbf
    X.shx

    where X is the shapefile name.
    """
    bpr_param_list = parse_bpr_param_matrix(matrix_filename)

    sql = subprocess.Popen("spatialite", shell=True,
        stdin=subprocess.PIPE, stdout=subprocess.PIPE, close_fds=True)

    sql.stdin.write(".loadshp " + road_shapefile + " hwytable UTF-8\n")
    hwy_tempfile = os.tempnam(None, "net")
    sql.stdin.write(".output " + hwy_tempfile + "\n")
    # DODGY FIXME = still don't know what these linktypes mean,
    # but centroid connectors are linktype 1. I thought 19 was the hghest
    # 'real' linktype but we need 20 to connect freeway slip lanes,
    # who knows that > 20 mean (there are some)?
    sql.stdin.write("select A,B,CAPACITY,LINKTYPE,CAPINDEX,DISTANCE from hwytable where linktype >= 1 and linktype <= 20;\n")
    sql.stdin.write(".output stdout\n")

    node_tempfile = os.tempnam(None, "node")
    sql.stdin.write(".loadshp " + node_shapefile + " nodetable UTF-8\n")
    sql.stdin.write(".output " + node_tempfile + "\n")
    sql.stdin.write("select N,X(Geometry), Y(Geometry) from nodetable;\n")
    sql.stdin.write(".output stdout\n")

    zone_tempfile = os.tempnam(None, "zone")
    sql.stdin.write(".loadshp " + zone_shapefile + " zonetable UTF-8\n")
    sql.stdin.write(".output " + zone_tempfile + "\n")
    sql.stdin.write("select ZONE_2253,X(Centroid(Geometry)),Y(Centroid(Geometry)) from zonetable;\n") # FIXME hardcoded ZONE_2253 for Melbourne data (but what can you do?)
    sql.stdin.write(".output stdout\n")
         

#     # run query to get nodes near zones
#     nearnode_tempfile = os.tempnam(None, "znode")
#     sql.stdin.write(".output " + nearnode_tempfile + "\n")
#     sql.stdin.write(
#         "select zonetable.zone_2253,nodetable.N,distance(centroid(zonetable.Geometry),nodetable.Geometry) from nodetable,zonetable  where Distance(centroid(zonetable.Geometry),nodetable.Geometry) < 3192;\n" # FIXME arbitrary; but 100 was too small (e.g. zone 295) and so was 1000 (e.g. zone 242) and so was 2000 (e.g. zone 689) and 3000 ( zones 689, 695)
# #spatialite> select  min(distance(centroid(zonetable.Geometry),DoT_nodes.Geometry)) from DoT_Nodes,zonetable where zonetable.zone_2253 = 689 ;
# #min(distance(centroid(zonetable.Geometry),DoT_nodes.Geometry))
# #3191.4001861382
# #CPU Time: user 55.803517 sys 0.027996

#         ) # FIXME this query is extremely slow (hours ) - cannot get any indexing to help - spatialite not really that good for spatial queries
#     sql.stdin.write(".output stdout\n")

 
# #    nearnode_tempfile = '/tmp/znodenMWIPF'


    sql.stdin.close()
    sys.stderr.write(str(sql.stdout.readlines()))
    sql.stdout.close()



    max_node_num = 0
    for line in open(node_tempfile):
        nodenum = int(line.split('|')[0])
        max_node_num = max(nodenum, max_node_num)
    num_nodes = max_node_num
    max_zone_num = 0
    for line in open(zone_tempfile):
        zone_num = int(float(line.split('|')[0])) # zone num is a float (why?)
        max_zone_num = max(zone_num, max_zone_num)
    num_zones = max_zone_num
    first_thru_node = num_zones + 1


    links = []
    # add all links from roads ESRI file
    for line in open(hwy_tempfile):
        sline = line.split('|')
        link = Link()
        link.init_node = int(sline[0])
        link.term_node = int(sline[1])
        link.capacity = int (sline[2])
        link.link_type = int(sline[3])
        capindex = int(sline[4])
        if link.link_type != 1 and capindex < 1:
            sys.stderr.write("warning: capindex %d changed to %d for link"
                             " %d -> %d\n" % (capindex, 2, link.init_node,
                                              link.term_node))
            capindex = 2
        elif link.link_type != 1 and capindex >= len(bpr_param_list):
            sys.stderr.write("warning: capindex %d changed to %d for link"
                             " %d -> %d\n" (capindex, len(bpr_param_list)-1,
                                            link.init_node,link.term_node))
            capindex = len(bpr_param_list)-1
           

        link.length         = float(sline[5])
        freeflowspeed = bpr_param_list[capindex][2]
##        sys.stderr.write('XXX CAPINDEX = %d freeflowspeed = %f\n' %(capindex, freeflowspeed)) 
        if freeflowspeed == 0:
            assert capindex == 1 # centroid connector
            assert link.link_type == 1 # centroid connector
            link.free_flow_time = 0
        else:
            link.free_flow_time = link.length / freeflowspeed # T_0 in BPR function
        link.B              = bpr_param_list[capindex][0] # alpha in BPR function
        link.power          = bpr_param_list[capindex][1] # beta in BPR function
        link.speed_limit    = freeflowspeed # NB using free flow speed for this
        link.toll           = 0     # TODO get this somehow
        links.append(link)

    #
    # now create link from each zone to its nearest node (and reverse link)
    # but only for nodes that have a link (many do not - spatialite too
    # slow to filter these out with SQL query though within days,
    # faster to write my own script to do it here)
    #

    # first create dict { node : True } for nodes that have a link out AND
    # one for links in
    node_linksout = {}
    for link in links:
        node_linksout[link.init_node] = True
    if len(node_linksout) < num_nodes:
        sys.stderr.write(
          "warning: of %d nodes implied by hwy data, %d have no links out\n" %
          (num_nodes, num_nodes - len(node_linksout)))
    node_linksin = {}
    for link in links:
        node_linksin[link.term_node] = True
    if len(node_linksin) < num_nodes:
        sys.stderr.write(
          "warning: of %d nodes implied by hwy data, %d have no links in\n" %
          (num_nodes, num_nodes - len(node_linksin)))


    # don't need to do this, it seems nodes with number < 5000 are
    # actually zone centroids (although only 2253 used) and
    # links with linktype==1 are centroid connectors

 
    # dist_dict = {}  # dict { zone :  [ (dist, node) ] }
    # for line in open(nearnode_tempfile):
    #     sline = line.split('|')
    #     zone = int(float(sline[0])) # for some reason it has zone number as float
    #     node = int(sline[1]) + num_zones # 1..num_zones are zones not thru nodes
    #     dist = float(sline[2])
    #     if node_linksout.has_key(node) and node_linksin.has_key(node):
    #         if not dist_dict.has_key(zone):
    #             dist_dict[zone] = [ (dist, node) ] # dist first for comparisons
    #         else:
    #             dist_dict[zone].append( (dist, node) )
    # for zone,distlist in dist_dict.iteritems():
    #     mindist,nearest_node = min(distlist)
    #     link = Link()
    #     link.init_node = zone
    #     link.term_node = nearest_node
    #     link.capacity = 100000
    #     link.link_type = 0
    #     link.length         = mindist
    #     link.free_flow_time = 0     # T_0 in BPR function 
    #     link.B              = 0.15  # alpha in BPR function
    #     link.power          = 4.0   # beta in BPR function
    #     link.speed_limit    = 0
    #     link.toll           = 0
    #     links.append(link)
    #     link = Link()
    #     link.init_node = nearest_node
    #     link.term_node = zone
    #     link.capacity = 100000
    #     link.link_type = 0
    #     link.length         = mindist
    #     link.free_flow_time = 0     # T_0 in BPR function 
    #     link.B              = 0.15  # alpha in BPR function
    #     link.power          = 4.0   # beta in BPR function
    #     link.speed_limit    = 0
    #     link.toll           = 0
    #     links.append(link)

    # links.sort(cmp=linkcmp)

    #
    # We want to remove all nodes that have no links in or out
    # But node numbering has to be sequential so build a dict
    # { node_num : new_node_num } mapping the current node numbers,
    # for nodes with links only, to a new sequential numbering
    #

    # # 1..num_zones unchanged, we made links for them
    # renumber_dict = dict([(i, i) for i in xrange(1,num_zones+1)])
    renumber_dict = {}
    # assert first_thru_node == num_zones+1
    # seqnum = first_thru_node
    seqnum = 1
    # for node in xrange(first_thru_node, num_zones+num_nodes+1):
    for node in xrange(1, num_nodes+1):
        if node_linksout.has_key(node) or node_linksin.has_key(node):
            renumber_dict[node] = seqnum
            seqnum += 1

    sys.stderr.write("removing %d nodes with no links in or out\n" %
                     (num_nodes - len(renumber_dict)))
        

    # write net file

    netfile_fh.write("<NUMBER OF ZONES> " + str(num_zones) + "\n")
    netfile_fh.write("<NUMBER OF NODES> " + str(len(renumber_dict)) + "\n")
    netfile_fh.write("<FIRST THRU NODE> " + str(first_thru_node) + "\n")
    netfile_fh.write("<NUMBER OF LINKS> " + str(len(links)) + "\n")
    netfile_fh.write("<END OF METADATA>\n")
    netfile_fh.write("\n")
    netfile_fh.write("~\tInit node\tTerm node\tCapacity\tLength\tFree Flow Time\tB\tPower\tSpeed limit\tToll\tType\t;\n")
    for link in links:
        # all nodes must be in renumber_dict as they have a link so not removed
        netfile_fh.write("\t%d\t%d\t%f\t%f\t%f\t%f\t%f\t%f\t%f\t%d\t;\n" %
                         (renumber_dict[link.init_node],
                          renumber_dict[link.term_node],
                          link.capacity,link.length,link.free_flow_time,
                          link.B,link.power,link.speed_limit,
                          link.toll,link.link_type))

    # write node file

    nodefile_fh.write("Node\tX\tY\t;\n")
    # # write zones as nodes first (these are never removed)
    # for line in open(zone_tempfile):
    #     sline = line.split('|')
    #     n = int(float(sline[0])) # for some reason it has zone number as float
    #     x = float(sline[1])
    #     y = float(sline[2])
    #     nodefile_fh.write("%d\t%f\t%f\t;\n" % (renumber_dict[n], x, y))
    # now the actual nodes - only write those with links in or out
    for line in open(node_tempfile):
        sline = line.split('|')
        # n = int(sline[0]) + num_zones # 1..num_zones are zones not thru nodes
        n = int(sline[0])
        if renumber_dict.has_key(n):
            x = float(sline[1])
            y = float(sline[2])
            nodefile_fh.write("%d\t%f\t%f\t;\n" % (renumber_dict[n], x, y))
                     

    # write the map file mapping orig numbers to new sewquentoial node numbers
    for (oldnum,newnum) in sorted(renumber_dict.iteritems()):
        mapfile_fh.write('%d\t%d\n' % (oldnum, newnum))

    os.unlink(hwy_tempfile)
    os.unlink(node_tempfile)
    os.unlink(zone_tempfile)
#FIXME    os.unlink(nearnode_tempfile) 

#-----------------------------------------------------------------------------
#
# Main
#
#-----------------------------------------------------------------------------

def usage(progname):
    """
    Print usage message and exit
    """

    sys.stderr.write("Usage: " +progname + " road_shapefile node_shapefile zone_shapefile bprmatrixfilename netfilename nodefilename\n")
    sys.exit(1)


def main():
    """
    main for esri2tapnetnode.py

    Usage: esri2tapnetnode.py road_shapefile node_shapefile zone_shapefile bprmatrix_filename netfilename nodefilename

    road_shapefile is the ESRI shapefile containing roads (links) data
    node_shapefile is the ESRI shapefile containing nodes data
    zone_shapefile is the ESRI shapefile containing zones data
    bprmatrix_filename is name of MATLAB ascii matrix file of BPR parameters
    netfilename is the name of the output net file (WARNING: overwritten)
    nodefilename is the name of the output node file (WARNING: overwritten)

    Note input shapefiles have the names

    X.shp
    X.dbf
    X.shx

    where X is the shapefile name.

    A mapping from original node numbers to renumbered (after deleting nodes
    with no links) seqwuential nuode numbers is written to stdout in form
   
    oldnum newnum

    one per line.
   
    Example usage:

       esri2tapnetnode.py  HWY_Base2008AM_V090414_polyline NODES_HWY_Base2008AM_V090414_point  Zones_2253_region bprparams.matrix melbourne_net.txt melbourne_node.txt
    """
    if len(sys.argv) != 7:
        usage(os.path.basename(sys.argv[0]))

    timestamp = strftime("%d%b%Y %H:%M:%S", localtime())

    road_shapefile = sys.argv[1]
    node_shapefile = sys.argv[2]
    zone_shapefile = sys.argv[3]
    bprmatrix_filename = sys.argv[4]
    netfilename = sys.argv[5]
    nodefilename = sys.argv[6]

    netfile_fh = open(netfilename, "w")
    nodefile_fh = open(nodefilename, "w")
    mapfile_fh = sys.stdout

    netfile_fh.write('~ Generated by: ' + ' '.join(sys.argv) + '\n')
    netfile_fh.write('~ On: ' + timestamp + '\n')
    nodefile_fh.write('~ Generated by: ' + ' '.join(sys.argv) + '\n')
    nodefile_fh.write('~ On: ' + timestamp + '\n')
    mapfile_fh.write('~ Generated by: ' + ' '.join(sys.argv) + '\n')
    mapfile_fh.write('~ On: ' + timestamp + '\n')
    mapfile_fh.write('~oldNodeNum\tnewNodeNum\n')
                     

    esri2tapnetnode(road_shapefile, node_shapefile, zone_shapefile,
                    bprmatrix_filename,
                    netfile_fh, nodefile_fh, mapfile_fh)

    netfile_fh.close()
    nodefile_fh.close()


if __name__ == "__main__":
    main()

