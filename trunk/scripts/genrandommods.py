#!/usr/bin/env python
##############################################################################
#
# genrandommods - Generate random road network modifications
#
# File:    genrandommods.py
# Author:  Alex Stivala
# Created: July 2011
#
# $Id: genrandommods.py 643 2011-09-01 05:47:35Z astivala $
#
#
##############################################################################

"""

Usage:
   genrandommods.py [-n] [-r] -c num_changes -a num_adds netfilename nodefilename

      -r                make more 'realstic' road network upgrades by
                        modifiying whole roads (not just single links)
                        in each change.
      -n                operate in 'neighbourhood' mode: make one change
                        then create the others near it.
      -c num_changes    specifies the number of links to change
      -a num_adds       specified the number of links to add
      netfilename    is name of the net file defining node and links
      nodefilename   is name of node file giving x,y cooridinates for nodes

   Output is netowrk modifications file on stdout (parse with parse_mod_file)
   
Example usage:
     genrandommods.py -c 4 -a 0 ChicagoRegional_net.txt ChicagoRegional_node.txt
     
"""

import sys
import getopt
from time import strftime, localtime
import random
from math import sqrt

from parsetapfiles import Link,Net,parse_net_file,parse_node_file,net_to_linkdict,\
     net_to_graph
     
#-----------------------------------------------------------------------------
#
# Constants
#
#-----------------------------------------------------------------------------
CAPACITY_MULTIPLIER = 2.0 # link change is 100% increase in capacity

DIST_FRACTION = 10.0  # neigbhourhood is within maxdist/DIST_FRACTION of a node

#-----------------------------------------------------------------------------
#
# main
#
#-----------------------------------------------------------------------------

def usage(progname):
    """
    print usage msg and exit
    """
    sys.stderr.write("usage: " + progname +
                  "[-n] [-r] -c num_changes -a num_adds netfilename nodefilename\n")
    sys.stderr.write("-n : neighbourhood mode - make changes locally\n")
    sys.stderr.write("-r : make more realistic change by changing whole roads (multiple links)\n")
    sys.stderr.write("-c num_changes : number of change (capacity increase) to make\n")
    sys.stderr.write("-a num_ads : number of links to create\n")
    sys.exit(1)

def main():
    """
    See usage message in module header block
    """
    num_changes = None
    num_adds = None
    neighbourhood_mode = False
    road_mode = False
    
    try:
        opts,args = getopt.getopt(sys.argv[1:], "nrc:a:")
    except:
        usage(sys.argv[0])
    for opt,arg in opts:
        if opt == "-c": 
            num_changes = int(arg)
        elif opt == "-a":
            num_adds = int(arg)
        elif opt == "-n":
            neighbourhood_mode = True
        elif opt == "-r":
            road_mode = True # change whole roads (multiple links)
        else:
            usage(sys.argv[0])

    if len(args) != 2:
        usage(sys.argv[0])

    if num_changes == None or num_adds == None:
        usage(sys.argv[0])            

    net_filename = args[0]
    nodefilename = args[1]

    timestamp = strftime("%d%b%Y %H:%M:%S", localtime())

    net = parse_net_file(net_filename)
    nodexydict = parse_node_file(nodefilename)

    real_nodes = range(net.first_thru_node,
                       net.num_nodes - net.first_thru_node)

    real_links = [link for link in net.links if
                  link.init_node >= net.first_thru_node and
                  link.term_node >= net.first_thru_node]
    num_real_links = len(real_links)
                  
    if num_real_links < num_changes:
        sys.stderr.write("ERROR: only %d (non-centroid-connector) links but %d mods requested\n" %
                         (num_real_links, num_changes))
        sys.exit(1)

    outfh = sys.stdout
    outfh.write('~ Generated by: ' + ' '.join(sys.argv) + '\n')
    outfh.write('~ On: ' + timestamp + '\n')
    outfh.write('~ changeId\tchangeType\tfrom \tto\tcapacity\tlength\tftime\tB\tpower\tspeed\ttoll\ttype\tprojectCost\n')

    if neighbourhood_mode:
        if (num_changes < 1):
            sys.stderr.write(
                 "ERROR: must have at least once change for -n option\n")
            sys.exit(1)
        num_changes -= 1
        change_links = random.sample(real_links, 1)
        link = change_links[0]
        changetype = "CHANGE"
        changeid = 'change_nc'
        new_capacity = link.capacity * CAPACITY_MULTIPLIER
        projectcost = round(random.uniform(500, 10000)) * 1000
        outfh.write("%s\t%s\t%d\t%d\t%f\t%f\t%f\t%f\t%f\t%f\t%f\t%d\t%.2f\t;\n" %
                         (changeid, changetype,
                          link.init_node, link.term_node,
                          new_capacity,
                          link.length,link.free_flow_time,
                          link.B,link.power,link.speed_limit,
                          link.toll,link.linktype, projectcost))
        # set available_nodes to nodes in neighbourhood and
        # available_links to links that are connected to those nodes
        node1 = link.init_node
        dist_node_list= [ (sqrt( (nodexydict[node2][0] - nodexydict[node1][0])**2
                                +(nodexydict[node2][1] - nodexydict[node1][1])**2
                               ),
                           node2
                          ) for node2 in real_nodes
                        ]
        dist_node_list.sort() # sort by distance (first) ascending
        maxdist = dist_node_list[-1][0]
        available_nodes = [ node for (dist,node) in dist_node_list
                            if dist < maxdist / DIST_FRACTION ]
        sys.stderr.write('neighbourhood: %d of %d nodes are within dist %f\n'
                         % (len(available_nodes), len(real_nodes),
                            maxdist/DIST_FRACTION))
        avail_nodes_dict = dict( [(node,True) for node in available_nodes] )
        available_links = [ link for link in real_links if
                            avail_nodes_dict.has_key(link.init_node) or
                            avail_nodes_dict.has_key(link.term_node) ]
    else:
        available_nodes = real_nodes
        available_links = real_links
        


    if num_adds > 0:
        # get a random sample of nodes and, for each node,
        # add a link from and to nearest (Euclidean distance)
        # node it does not already
        # have a link to
        if len(available_nodes) < num_adds:
            sys.stderr.write(
             "ERROR: only %d available nodes but %d adds requested\n" %
             (len(available_nodes), num_adds))
        addlink_nodes = random.sample(available_nodes, num_adds)
        linkdict = net_to_linkdict(net)
        for i in xrange(len(addlink_nodes)):
            node1 = addlink_nodes[i]
            (dist,node2) = min(                 
                        [ (sqrt( (nodexydict[node2][0] - nodexydict[node1][0])**2
                                +(nodexydict[node2][1] - nodexydict[node1][1])**2
                               ),
                           node2
                          ) for node2 in available_nodes
                            if node2 != node1 and
                            not ( linkdict.has_key((node1,node2)) or
                                  linkdict.has_key((node2,node1)) )
                        ]
                       )
            links_at_node1 = [link for link in real_links if
                              link.init_node == node1 or link.term_node == node1]
            copylink = links_at_node1[0] # copy attributes from this link
            link = Link()
            link.init_node = node1
            link.term_node = node2
            link.capacity = copylink.capacity
            link.length = dist
            link.free_flow_time = copylink.free_flow_time
            link.B = copylink.B
            link.power = copylink.power
            link.speed_limit = copylink.speed_limit
            link.toll = copylink.toll
            link.linktype = copylink.linktype
            changetype = "ADD"
            changeid = 'addlink_' + '%02d' % i
            projectcost = round(random.uniform(500, 10000)) * 1000 * 2
            outfh.write(
                "%s\t%s\t%d\t%d\t%f\t%f\t%f\t%f\t%f\t%f\t%f\t%d\t%.2f\t;\n" %
                         (changeid, changetype,
                          link.init_node, link.term_node,
                          link.capacity,
                          link.length,link.free_flow_time,
                          link.B,link.power,link.speed_limit,
                          link.toll,link.linktype, projectcost/2))
            link.init_node = node2
            link.term_node = node1
            outfh.write(
                "%s\t%s\t%d\t%d\t%f\t%f\t%f\t%f\t%f\t%f\t%f\t%d\t%.2f\t;\n" %
                         (changeid, changetype,
                          link.init_node, link.term_node,
                          link.capacity,
                          link.length,link.free_flow_time,
                          link.B,link.power,link.speed_limit,
                          link.toll,link.linktype, projectcost/2))
            
            


    if road_mode:
        # get links between nodes that only have 1 or 2 links
        # ie no intersections. then when one is chosen we will increase capacity
        # all along this single path (to intersections, i.e. nodes with 2 or
        # more links) at either end
        netgraph = net_to_graph(net)
        linkdict = net_to_linkdict(net)
        available_nodes = [node for node in available_nodes
                           if len(netgraph[node]) < 3 and len(netgraph[node]) > 0]
        # build reversed graph (all links reversed from original)
        rev_netgraph = dict((i,{}) for i in xrange(1, net.num_nodes+1))
        for (fromnode, nodedict) in netgraph.iteritems():
            for (tonode, cost) in nodedict.iteritems():
                rev_netgraph[tonode][fromnode] = cost
#        print 'aaa len(availabe_nodes) = ', len(available_nodes)

    for i in xrange(num_changes):
#        print 'xxx i =',i
        if road_mode: 
            startnode = random.sample(available_nodes, 1)[0]
            node = startnode
            nodelist = []
#            print 'bbb',node
            # add nodes forward to next intersection
            while (len(netgraph[node]) < 3 and node > net.first_thru_node):
                if  (node!=startnode and node  in nodelist):
                    break
                nodelist.append(node)
                node = list(netgraph[node])[0]
#                print  'www',node
#                print 'www2',len(netgraph[node])
            if node != startnode:
                nodelist.append(node)
            # add nodes back to previsou intersection
            node = startnode
            while (len(rev_netgraph[node]) < 3 and node > net.first_thru_node):
                if  (node != startnode and node  in nodelist):
                    break
#                print 'qqq',len(rev_netgraph[node])
                if node != startnode:
                    nodelist.insert(0, node)
                node = list(rev_netgraph[node])[0]
#                print 'yyy',node
            if node != startnode:
                nodelist.insert(0, node)
#            print 'ccc',nodelist
            path = zip(nodelist, nodelist[1:]) #convert to list of edge tuples
            linklist = [linkdict[(fromnode, tonode)] for (fromnode, tonode) in path]
            # add reverse direction
            linklist.extend([linkdict[(tonode, fromnode)]
                             for (fromnode, tonode) in reversed(path)
                             if linkdict.has_key((tonode, fromnode)) ])
        else:
            linklist = random.sample(available_links, 1)
        changetype = "CHANGE"
        changeid = 'change_' + '%02d' % i
        for link in linklist:
            new_capacity = link.capacity * CAPACITY_MULTIPLIER
            projectcost = round( random.uniform(500, 10000) * 1000 / len(linklist) )
            outfh.write("%s\t%s\t%d\t%d\t%f\t%f\t%f\t%f\t%f\t%f\t%f\t%d\t%.2f\t;\n" %
                        (changeid, changetype,
                         link.init_node, link.term_node,
                         new_capacity,
                         link.length,link.free_flow_time,
                         link.B,link.power,link.speed_limit,
                         link.toll,link.linktype, projectcost))
            
    
if __name__ == "__main__":
    main()
